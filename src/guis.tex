
% Copyright 2020-2024 Facundo Batista y Manuel Carlevaro
% Licencia CC BY-NC-SA 4.0
% Para más info visitar https://github.com/facundobatista/libro-pyciencia/

\chapter{Interfaces gráficas} \label{ch:guis}

Las interfaces que nos ofrecen los programas en un sistema informático se dividen principalmente entre si están pensada para otras aplicaciones o para personas. Estas últimas a su vez se dividen en varios tipos, siendo las gráficas nuestro motivo de estudio en este capítulo.

\begin{wraptable}{r}{5cm}
\begin{modulesinfo}
\begin{center}
{\small
    \begin{tabular}{l r}
        \toprule
        \textbf{Módulo} & \textbf{Versión} \\
        \midrule
        matplotlib & 3.9.2 \\
        PyQt6 & 6.7.1 \\
        scipy & 1.14.1 \\
        \bottomrule
    \end{tabular}
    \vspace{0.75em}

    \href{https://github.com/facundobatista/libro-pyciencia/tree/master/código/guis/}{Código disponible}
}
\end{center}
\end{modulesinfo}
\end{wraptable}

También conocidas como GUI (del inglés \textit{graphical user interface}), las interfaces gráficas utilizan un conjunto de imágenes y objetos gráficos para representar la información y acciones disponibles. Es una herramienta muy poderosa a la hora de proporcionar un entorno visual sencillo para permitir la utilización de nuestro sistema por quienes necesiten usarlo.

No es un concepto para nada nuevo, las interfaces gráficas datan de la década de 1970, y por eso hay infinidad de variaciones. Sólo a modo de ejemplo, podemos citar algunos frameworks que son multiplataforma, como \href{https://www.qt.io/}{Qt}, \href{https://www.gtk.org/}{GTK+} o \href{https://www.tcl.tk/}{Tk}, y otros que son específicos a algún sistema operativo, como \href{https://en.wikipedia.org/wiki/Cocoa_(API)}{Cocoa} para MacOS o las \href{https://learn.microsoft.com/en-us/cpp/mfc/mfc-desktop-applications}{Microsoft Foundation Classes (MFC)} para Windows. Y no sólo tenemos que pensar en computadoras de escritorio o laptops, por ejemplo con \href{https://kivy.org/}{Kivy} también podemos armar programas con interfaces gráficas para teléfonos.

Para este capítulo vamos a utilizar Qt, aunque la gran cantidad de conceptos sobre los que hablaremos son comunes a todos los frameworks de interfaces gráficas, más allá de sus características particulares.


\section{Qt}

Qt es un framework para construir interfaces gráficas (aunque también tiene su utilización en sistemas no gráficos) que corre en los tres principales sistemas operativos de escritorio (Linux, MacOS y Windows), algunos modelos de teléfonos y sistemas integrados, y hay planes a futuro para que funcione en Android e iOS.

Al ser una sigla vale la pena la aclaración con respecto a su pronunciación: en castellano decimos ``cu-té'', mientras que en inglés se pronuncia ``quiút'' (no ``quiú-ti'').

En realidad no vamos a usar Qt directamente, porque tendríamos que programar en C++, sino que vamos a usar PyQt, un \textit{wrapper} alrededor del framework base. Mencionaremos luego algunas diferencias, pero para todos los efectos prácticos, seguiremos hablando de Qt o PyQt indistintamente en el resto del capítulo.

Qt, como la mayoría de los frameworks de interfaces gráficas, es un sistema asincrónico (si todavía no leyeron la sección sobre Async\ref{sec:async} es un buen momento, pero no es estrictamente necesario para entender el resto de este capítulo). Por eso podemos decir que un programa de interfaz gráfica está basado en eventos: una vez que arrancó y terminó de armar todos los elementos en una ventana el sistema no estará realmente haciendo nada hasta que reciba eventos y los procese.

Estos eventos pueden venir de distintas fuentes: entrada del usuario (vía el teclado o el mouse, por ejemplo) o del sistema (alarmas luego que pasó determinado tiempo, escritura o lectura en distintas entradas/salidas, etc). Cuando sucede el evento el reactor que maneja el sistema asincrónico (Qt mismo) ejecutará la función correspondiente para manejarlo.

Tengamos en cuenta que no todos los eventos nos interesan en una aplicación de interfaz gráfica. Aunque esos eventos son todo lo que le puede ``suceder'' a una ventana de nuestra aplicación, hay muchos que están manejados directamente por los componentes que ya agregamos a esa ventana. Por ejemplo, si dejamos el mouse quieto sobre uno de los iconos de la barra de herramientas de nuestra aplicación aparecerá un mensaje, pero supervisar al mouse para detectar la situación y hacer aparecer ese mensaje no es algo que tengamos que programar de nuestro lado, es una funcionalidad integrada del componente mismo que usamos para tener ese icono en esa barra de herramientas, al cual sólo le tenemos que indicar qué mensaje queremos que aparezca en ese caso.

Por otro lado, hay muchas veces que sí queremos reaccionar a los distintos eventos. Por ejemplo, ponemos un botón en nuestra aplicación y queremos ejecutar una función ``nuestra'' cuando se presiona ese botón. Ya veremos cómo se hace esto.

Estos componentes de la interfaz gráfica se llaman \textit{widgets} (la traducción al castellano es ``artilugio'' pero en realidad siempre usamos \textit{widget}) y permiten hacer uso de la aplicación y los servicios que esta provee. Como ejemplo, mencionamos aquí algunos widgets utilizando su nombre en Qt y la funcionalidad que ofrecen (estos son widgets bien simples, en la mayoría de otras interfaces gráficas encontraremos widgets similares a estos con nombres parecidos o casi iguales):

\begin{itemize}
\item QLabel: muestra un texto o imagen
\item QLineEdit: permite ingresar una línea de texto
\item QTextEdit: permite ingresar un texto de cualquier cantidad de líneas
\item QPushButton: un botón para invocar una acción al ser apretado
\item QRadioButton: permite elegir una opción (y sólo una) entre muchas
\item QCheckBox: permite elegir una o más opciones
\item QDialog: otra ventana con una funcionalidad acotada y específica usada para recabar información desde la ventana que la genera
\end{itemize}

Si pensamos en cualquier programa de interfaz gráfica reconoceremos que usan alguna combinación de los widgets recién mencionados, entre otros. Más adelante en este capítulo mismo usaremos algunos de esos widgets y otros también.


\subsection{Unas palabras sobre la documentación}

Como mencionamos antes, en este capítulo vamos a utilizar PyQt para explicar los conceptos de interfaces gráficas y armar una aplicación ejemplo.

Si buscamos documentación online sobre PyQt encontraremos muchos tutoriales y ejemplos de cómo hacer distintas aplicaciones o estructurar distintas funcionalidades haciendo el programa en Python. Pero a la hora de buscar la documentación de referencia de los distintos widgets y otros componentes de PyQt, veremos que casi no hay nada, y siempre en algún punto terminan apuntando a la referencia escrita para Qt mismo, en C++.

Esto sucede porque PyQt es una capa arriba de la biblioteca de Qt en C++, permitiendo (más allá de proveer alguna simplicidad extra) poder usarla desde Python. Reescribir toda la documentación para hacerla en PyQt sería un esfuerzo mayúsculo, por el tamaño de la misma y por el hecho de que cambia continuamente (especialmente entre las versiones principales de la librería, de Qt 4 a Qt 5, por ejemplo). Esto, sumado a que entender la documentación en C++ (aunque usemos PyQt) es bastante sencillo, hace que nunca se encare ese esfuerzo.

Un buen punto de entrada a la documentación de referencia es \href{https://doc.qt.io/qt-6/classes.html}{la lista de todas las clases disponibles}, porque en general nos va a suceder que sabemos que tenemos que usar un determinado widget, pero no sabemos cómo explotarlo al máximo o queremos aprender de sus distintas funcionalidades. Desde allí podremos ir a cualquiera de las clases que usaremos cuando programamos en (Py)Qt.

Entonces la idea es transmitirles que intenten usar la documentación escrita en C++, que a priori parecerá muy críptica pero es cuestión de acostumbrarse a leerla para poder aprovecharla. Para facilitarles este proceso les recomendamos en hacer foco en las siguientes secciones cuando vayan a la documentación de referencia de alguno de los widgets:

\begin{itemize}
\item\textit{Public Functions} y \textit{Reimplemented Public Functions}: aquellos métodos del widget que podemos llamar para explotar todas sus posibilidades.
\item\textit{Signals}: aquellas señales a las que les podemos conectar una función nuestra para reaccionar a eventos en el widget (o directamente conectarles un \textit{slot}... hablaremos luego más en profundidad sobre \textit{signals} y \textit{slots})
\item\textit{Detailed Description}: una explicación a fondo de para qué sirve el widget, donde normalmente se mencionan distintas opciones y capacidades funcionales, y es un gran punto de entrada no sólo para aprender sobre el widget sino para entender los contextos en los que se lo puede utilizar.
\end{itemize}

Cabe destacar que todas estas clases tienen una estructura de herencia, y también tenemos que acostumbrarnos a eso cuando busquemos información. Por ejemplo, si vamos a la documentación del \href{https://doc.qt.io/qt-6/qpushbutton.html}{QPushButton} (el botón ``normal'' de cualquier interfaz gráfica) veremos que no tiene ninguna señal listada... pero encontramos que hereda de \href{https://doc.qt.io/qt-6/qabstractbutton.html}{QAbstractButton} (la clase de la que derivan los distintos tipos de botones) y ahí están las señales que estábamos buscando, como \texttt{clicked}, que se emite cuando el botón es activado (o sea, apretado y soltado mientras el cursor del mouse está dentro del botón).

Luego podrán explorar más a fondo, pero ya con esta información podrán acceder a la documentación de la mayor parte de la funcionalidad que van a necesitar.


\section{Una aplicación mínima}

Para empezar a entender las distintas funcionalidades que podemos encontrarnos en una aplicación gráfica, y cómo usar esas funcionalidades desde PyQt, armemos una aplicación muy básica.

Este mínimo de código que presentaremos en esta sección nos permitirá charlar sobre distintos conceptos fundamentales, y luego podremos encarar una aplicación más real.

Arranquemos con la ``cáscara'' mínima que necesitaremos siempre (el código en \texttt{01.empty.py}).

\pyfile{Chapters/guis/code/01.empty.py}

\begin{info}
Para ejecutar este ejemplo (y todos los de este capítulo) sigan las instrucciones del \texttt{README} que hay en el directorio de código correspondiente.
\end{info}

Aquí ya vemos las tres secciones que se repetirán en todos los programas. Primero, una secuencia de \textit{imports} (líneas 1 a 4), que irá creciendo a medida que vayamos necesitando más widgets y funcionalidades. Luego, todas las clases que compondrán la estructura de nuestra aplicación; en este caso tenemos sólo una (líneas 7 a 12), que explicaremos luego. Y finalmente una serie de instrucciones para que arranque el sistema (líneas 15 a 18).

Estas últimas líneas no cambiarán para nada en todo nuestro ejemplo, y en aplicaciones más reales sólo se verán afectadas según alguna necesidad de procesamiento de opciones de línea de comando (que en aplicaciones de interfaz gráfica no es normal tener). Lo más importante de esta secuencia es la inicialización de \texttt{QApplication}, la cual maneja la configuración a nivel QT y el flujo de control de la aplicación; contiene el \textit{event loop} principal que procesará y despachará todos los eventos, tanto los generados por los elementos de las ventanas como de otras fuentes.

Luego de inicializar \texttt{QApplication} (línea 15) instanciamos nuestra ventana y la mostramos (líneas 16 y 17), lo cual no podemos hacer antes (necesitan tener el sistema ya inicializado). Pero si terminamos ahí, nuestro programa no hará nada. Es que recién al ejecutar el \texttt{app.exec()} estamos dandole el control a \textit{event loop} de Qt, que se quedará manejando el sistema hasta que nuestra aplicación termine (devolviendo un código final que lo pasamos directamente a \texttt{sys.exit()} para que sea el código de retorno del proceso).

Enfoquémonos entonces en la parte del medio de nuestro programa.

La clase \texttt{Window} hereda de \texttt{QWidget}, y lo único que hacemos es ajustar tres detalles en tiempo de inicialización (luego de primero inicializar la clase padre en la línea 9: recordemos que cuando redefinimos un método que ya posee la clase de la que derivamos, al llamarse al método sólo se ejecutará el de la clase hija, y si queremos que también se ejecute el método de la clase ancestra debemos llamarlo explícitamente). Las tres líneas donde configuramos el \textit{widget} son bastante autoexplicativas: cambiamos el tamaño de la ventana, le ponemos un título, y le configuramos un icono.

En general construiremos toda nuestra aplicación gráfica heredando de determinados widgets y agregándole la funcionalidad particular que necesitamos en cada caso. Esta estructura no es obligatoria, pero al ser PyQt un framework fuertemente estructurado alrededor de un árbol de clases, si continuamos con esa metodología nos quedará un código prolijo y fácil de entender.

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-01-1.png}
\end{center}

En realidad una ventana vacía tampoco hace a una aplicación, agreguemos algo simple (un texto) y una forma de interacción (un botón que haga algo).

Pero antes, ahora que vamos a agregar widgets en nuestra ventana, unas palabras sobre dónde y cómo agregarlos.

En los comienzos de las aplicaciones gráficas, los elementos dentro de una ventana tenían una posición fija (incluso hoy en día se construyen aplicaciones así), donde cada widget se ubicaba en una coordenada específica dentro de la ventana. Esto siempre termina en una pobre experiencia en el uso, ya que si cambia el largo de los textos (por traducciones), o el tamaño de la ventana, o el tamaño de la tipografía (por configuraciones de accesibilidad del sistema), todo queda amontonado solapándose los elementos de la ventana o demasiado disperso.

Hay una forma superadora de ubicar elementos dentro de una ventana que es a través de \textit{layouts} (``disposiciones'', en castellano, pero se usa el término en inglés). Por ejemplo, si queremos poner tres widgets uno al costado del otro usaremos un \textit{layout} horizontal y agregaremos los tres widgets al layout. Tanto el tamaño del layout como de los widgets dentro se ajustarán dinámicamente en función del espacio mínimo que cada uno tiene que ocupar (por su contenido) y el tamaño máximo manejado por el usuario (por ejemplo al agrandar la ventana). Estos layouts tienen varias configuraciones que permiten controlar su comportamiento y ofrecer una solución elegante, como espacio entre los widgets, qué widget crecería con prioridad si se agranda la ventana, etc.

Obviamente hay layouts verticales y horizontales, y a través de su composición podemos lograr cualquier interfaz, pero también existen algunos más específicos, como un layout de grilla para aquellas disposiciones que son claramente una cuadrícula.

El segundo ejemplo lo tenemos en \texttt{02.content.py}, del cual mostraremos aquí sólo la clase del widget, ni la sección donde importamos los módulos necesarios ni las líneas para iniciar el programa. Para nuestra ventana ejemplo usaremos sólo un layout vertical, el cual instanciamos y configuramos como layout del widget en las líneas 15 y 16.

\pyfile[firstline=8, lastline=29]{Chapters/guis/code/02.content.py}

Los dos bloques de código siguientes crean y agregan al layout el texto y el botón.

El texto lo agregamos a través de un \texttt{QLabel}, al cual le indicamos que lo alinee al centro (atención a la forma de indicar esto, no se usan cadenas como \texttt{'center'} sino flags, ya predefinidas en el framework), y finalmente agregamos el widget al layout (líneas 18 a 25). Notar que tanto el mensaje como el widget en sí los creamos en la instancia de la ventana: esto es sólo necesario porque luego usaremos ambos desde un método de la instancia.

Al botón lo creamos directamente con el texto que queremos que tenga, luego conectamos su señal \texttt{clicked} a un método que creamos abajo, y agregamos el widget al layout (líneas 23 a 25). El método \texttt{happier} entonces se ejecutará cada vez que presionemos el botón: modificará el mensaje y le indicará al \texttt{QLabel} que tenemos en la ventana que use este nuevo texto.

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-02-1.png}
\end{center}

El botón que usamos, como la mayoría de los widgets, está diseñado para emitir señales en respuesta a uno o más eventos. Nosotros utilizamos \texttt{clicked}, pero tiene otras (en realidad, como ya mencionamos antes, las hereda de \texttt{QAbstractButton}). Incluso podemos crear nosotros nuestras propias señales (y lo haremos casi al final de este capítulo)

Las señales, en general, pueden conectarse a cualquier función de Python (o más de una), las que pueden estar definidas para no recibir nada (como en nuestro caso) o el evento que generó la señal (cuando ese evento nos trae información que necesitemos). Es que las señales pueden generarse por distintas situaciones: muchas son iniciadas por una acción de la persona que usa la interfaz pero eso no es una regla, lo que dispara la señal dependerá de cual sea la señal. Tengamos en cuenta que la señal en sí misma no hace nada, cuando se dispare sólo terminará ejecutando una o más funciones que hayamos conectado manualmente o conectadas por el framework mismo.

\begin{center}
    \includegraphics[width=250pt,keepaspectratio=true]{Chapters/guis/imgs/signals-tofunc.pdf}
\end{center}

Por otro lado, cuando las conectamos no siempre tenemos que conectarlas a funciones de Python. También podemos conectarlas directamente a \textit{slots} que los widgets tienen. De esta manera podemos relacionar widgets entre sí y que unos reaccionen a eventos de otros. Aunque las opciones son limitadas, porque dependemos de los slots que tenga definido cada widget, es interesante estar atentos a la posibilidad ya que es una solución extremadamente eficiente (porque todo se resuelve dentro del framework compilado sin salir a la capa de Python).

\begin{center}
    \includegraphics[width=250pt,keepaspectratio=true]{Chapters/guis/imgs/signals-toslot.pdf}
\end{center}

Para terminar la sección y antes de arrancar con una aplicación más real, nos permitimos un comentario sobre por qué diseñamos la interfaz gráfica de la aplicación usando código y no un diseñador gráfico como \textit{Qt Designer}. Esta aplicación (no es la única, cada framework tiene algo similar) permite armar la ventana \textit{visualmente}. Esta forma de construir ventanas era de gran ayuda en la época en que los widgets se acomodaban a mano en posiciones específicas, pero al usar layouts esa ventaja se pierde. Construir nuestros widgets especializados en código nos permite lograr una mejor reutilización del código que armamos (por ejemplo, podemos tener un layout con una separación específica entre widgets y reutilizarlo todo el tiempo), y también es mucho más fácil buscar ayuda sobre cómo realizar determinadas cosas.


\section{Una aplicación real}

En esta sección vamos armar una aplicación completa con una doble intención: por un lado mostraremos varios widgets y técnicas necesarias cuando queremos dar una buena usabilidad sobre nuestro programa, y la otra es que ustedes tengan una aplicación ``base'' para construir las suyas, un código que puedan modificar y adaptar para cumplir vuestras necesidades.

Es por esto último que pensamos en una aplicación que bien podría ser típica en un entorno científico: permitir cargar un archivo de datos y mostrar un gráfico generado a partir de esos datos, según alguna opción. En nuestro caso el archivo está en formato CSV y los datos son coordenadas en el plano, el cálculo que hacemos es ajustar una función polinómica a esos puntos (dejando que se elija en la interfaz el grado de la función) y luego graficar los puntos en sí y la función ajustada.

Por razones pedagógicas partiremos del ejemplo mínimo que traemos de la sección anterior e iremos agregando gradualmente nuevas funcionalidades, explicándolas en cada caso. Pero si no les importa el \textit{spoiler}, pueden arrancar por el final y ejecutar el código \texttt{09.complete.py} para ver la aplicación terminada.

Pero, decíamos, vayamos por partes. El primer gran cambio con respecto a lo que teníamos antes es que no queremos una ventana así no más, sino una ventana ``principal'' a la que le podamos agregar menú, barra de tareas, e incluso una barra de estado. Tenemos todo esto implementado en \texttt{03.app.py}, del que mostramos sólo la clase principal:

\pyfile[firstline=14, lastline=60]{Chapters/guis/code/03.app.py}

En este código vemos las distintas secciones donde armamos la funcionalidad recién indicada, pero prestemos atención a que ya no tenemos un widget genérico sino que heredamos de \texttt{QMainWindow}. Entonces, además de ese detalle importante y las primeras líneas donde fijamos el tamaño de la ventana y ponemos el título y el icono...

\begin{itemize}
    \item creamos la barra de herramientas y la barra de estado, las agregamos a la ventana principal, y le pedimos la barra de menú (líneas 24 a 28)
    \item creamos distintas acciones como paso separado, ya que luego usaremos esas acciones tanto para el menú como para la barra de tareas (líneas 31 a 38); mencionaremos abajo algunos detalles de estas líneas para explicarlas mejor
    \item agregamos una sola acción a la barra de tareas, para abrir el archivo (línea 41)
    \item agregamos todas las acciones al menú, bajo dos secciones principales: Archivo y Ayuda (líneas 44 a 48); notar que el nombre de cada sección en el menú tiene un \texttt{\&} antes de alguna letra: esa letra estará subrayada al mostrarse y permitirá acceder a la sección con la tecla \textit{Alt} más esa letra
    \item mostramos un mensaje en la barra de estado que desaparecerá luego de 3 segundos (línea 50)
    \item y finalmente agregamos un texto como todo widget central en la ventana (que luego más adelante reemplazaremos por contenido más avanzado)
\end{itemize}

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-03-1.png}
\end{center}

Volvamos a la parte de creación de las acciones para resaltar algunos detalles.

La primer acción, para abrir el archivo de datos, es especial porque es la que usaremos también en la barra de tareas. Por eso es que nos interesa que tenga un icono con sentido (que no cargamos de un archivo, sino que lo tomamos del stock de imágenes del sistema operativo) y también un \textit{tooltip} (que es el texto que aparece cuando dejamos unos segundos el mouse quieto arriba del icono de la barra de tareas).

Por otro lado, las acciones de abrir el archivo y de mostrar el ``acerca de'' de la aplicación tienen su señal \texttt{triggered} conectada a métodos de nuestra clase (definidos en las líneas 56 a 60, pero todavía sin implementar). Notar que a la acción para salir del programa la conectamos directamente al slot \texttt{exit} de la aplicación ya que no hace falta que hagamos nada específico en el medio.

El próximo paso en la aplicación es permitir abrir un archivo y cargar los datos correspondientes. Es hora de implementar el método \texttt{on\_open}, el cual tenemos en \texttt{04.load.py}:

\pyfile[firstline=59, lastline=101]{Chapters/guis/code/04.load.py}

Podemos separar este código en estas partes conceptuales:

\begin{itemize}
    \item mostramos un mensaje en la barra de estado informando que estamos abriendo el archivo de datos (línea 61)
    \item abrimos un ``diálogo''  para dejar elegir un archivo (hablaremos más sobre diálogos a continuación) en la línea 64, el cual nos puede dar un resultado vacío (en ese caso informamos que no hay archivo seleccionado), o el path a un archivo
    \item si tenemos un path válido lo abrimos, leemos, y validamos que tenga dos columnas de números, saliendo por error ante cualquier problema (líneas 70 a 94)
    \item si procesamos todo bien llegamos a la línea 97 donde informamos que se abrió el archivo correctamente
    \item finalmente cambiamos el texto central con un mensaje que muestra la cantidad de registros cargados (líneas 99 a 101)
\end{itemize}

Esa gran cantidad de líneas, de la 71 a la 93, es donde procesamos el archivo de datos, validando en cada uno de los pasos que la estructura y el contenido estén como esperamos (reportando un error y abortando la carga si no). Primero abrimos el archivo y lo leemos completamente con el módulo \texttt{csv}, para abortar si no se pudo abrir o está corrupto a nivel estructura (líneas 70 a 77). Luego procesamos cada línea validando que tenga dos columnas, y convirtiendo a número cada uno de los valores con \texttt{float} (líneas 79 a 94). Al final tenemos en \texttt{data} a toda la información correctamente convertida.

Este procesamiento puede parecer demasiado detallado, pero es importante considerar todos los casos de error e informar correctamente cuando algo sale mal: es la diferencia entre un programa que es fácil de usar y nos guía ante cualquier problema, y un programa que falla por ``razones misteriosas''. Es verdad que la forma de mostrar cada error parece repetitiva y un poco oscura (sólo un mensaje en la barra de estado), pero vamos a mejorar esto en próximas iteraciones del código.

Vemos en la imagen cómo quedaría el error informado cuando abrimos un archivo malformado:

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-04-1.png}
\end{center}

Antes de continuar hablemos sobre el widget que usamos para abrir el archivo. Un ``diálogo'' o ``ventana diálogo'' (en inglés \textit{dialog window}) es una ventana que aparece arriba de la que la genera, usada en general para tareas cortas o comunicaciones breves con las personas que usan el programa. En el caso de nuestro ejemplo usamos \texttt{QFileDialog}, un diálogo con la función específica de permitir elegir un elemento del sistema de archivos. Particularmente, usamos su método de clase \texttt{getOpenFileName} que permite elegir un archivo que ya existe, pero el diálogo tiene otros métodos que permiten también seleccionar muchos archivos, elegir un directorio, elegir un path que quizás no exista todavía (útil para grabar un archivo nuevo), etc. Qt provee \href{https://doc.qt.io/qt-6/dialogs.html}{varios diálogos pre-armados}, pero siempre se puede heredar \href{https://doc.qt.io/qt-6/qdialog.html}{QDialog} para armar uno específico para lo que se necesite.

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-04-2.png}
\end{center}

Como regla general, los diálogos son modales. Una ventana es modal cuando bloquea la utilización de otras ventanas de la misma aplicación hasta que esa ventana se cierre, lo cual es muy útil para los diálogos, justamente, como en el caso de nuestro ejemplo donde no tiene sentido continuar a menos que se elija un archivo o se cancele el diálogo porque no se quiere elegir uno. Por otro lado, es normal tener ventanas no modales cuando la aplicación es de ventanas múltiples, donde se tienen simultáneamente varias ventanas abiertas de la misma aplicación y se puede usar cualquiera indistintamente.

En la próxima iteración de nuestro código, a continuación (en \texttt{05.messages.py}), nos ocuparemos de los mensajes.

Para simplificar el código de toda la aplicación creamos dos métodos, uno que muestre un mensaje en la barra de estado (y reemplazamos todas las llamadas a \texttt{self.\_status\_bar.showMessage} en las que había que poner siempre la misma duración), y otro para informar errores de forma genérica (al que llamamos en todos los casos de error al abrir y procesar el archivo fuente de datos).

\pyfile[firstline=61, lastline=68]{Chapters/guis/code/05.messages.py}

Este último método no sólo muestra el mensaje en la barra de estado (que era lo que hacían las distintas llamadas originales) sino que también levanta un diálogo informativo (con un icono correspondiente al estado \texttt{critical}, con el título ``Error'' y el mensaje necesario).

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-05-1.png}
\end{center}

Vemos en la imagen que tenemos una ventana modal (notar que la ventana ``padre'' está griseada porque no la podemos usar) con el mensaje de error, y ese mensaje aparece también en la barra de estado.

También nos ocupamos del método \texttt{on\_about} que ya teníamos vinculado a la acción del menú.

\pyfile[firstline=111, lastline=122]{Chapters/guis/code/05.messages.py}

Aquí volvemos a usar \texttt{QMessageBox} pero ahora para mostrar un dialogo con la estructura específica del \textit{about}: un título, un mensaje largo para el cuerpo, y un icono que no hace falta especificárselo si es el mismo que ya le configuramos a la aplicación.

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-05-2.png}
\end{center}

Es hora de ocuparnos del panel principal de la aplicación, en \texttt{06.leftpanel.py}.

Como es en ese panel donde tendremos toda la complejidad de mostrar los datos, es buena idea separar esa funcionalidad toda en otra clase, \texttt{MainPanel}, que explicaremos luego. En el código que teníamos hasta ahora lo único que haremos es eliminar esos textos temporales que teníamos (el inicial al abrir la aplicación y el que indicaba la cantidad de registros al abrir un archivo) y justamente integraremos el panel principal a la aplicación:

\pyfile[firstline=186, lastline=190]{Chapters/guis/code/06.leftpanel.py}

Este código es el que se ejecutará luego de abrir exitosamente un archivo: instanciamos \texttt{MainPanel} (pasando una referencia a la ventana principal, el path del archivo y los datos cargados), y ponemos esta instancia como widget central de la aplicación.

Notar como antes de instanciar un nuevo \texttt{MainPanel} validamos no tener uno de antes, y en tal caso lo cerramos. Esto es para soportar abrir distintos archivos todas las veces que sea necesario: cada vez que se abra un nuevo archivo se descartará el panel anterior y se colocará uno nuevo.

En \texttt{MainPanel}, decíamos, tendremos toda la funcionalidad de la aplicación: mostraremos los datos, dejaremos elegir con qué tipo de función se ajustarán esos datos, y mostraremos el gráfico resultante. Por ahora, sin embargo, ocupémonos de todo eso menos el gráfico.

\pyfile[firstline=61, lastline=97]{Chapters/guis/code/06.leftpanel.py}

Lo primero que hacemos al inicializar \texttt{MainPanel} es inicializar a su vez \texttt{QWidget} del cual heredamos y guardarnos en la instancia a esa ventana y los datos, que los vamos a usar más adelante.

Luego armamos el layout principal, horizontal, el cual tendrá dos layouts verticales en lo que llamaremos ``izquierda'' y ``derecha'', y lo ponemos como layout del widget. Notar que al layout de la derecha (que tendrá el gráfico o un símbolo de espera si el cálculo tarda mucho), le indicamos que tome todo el espacio disponible con \texttt{stretch=1} al agregarlo al layout principal y le configuramos su alineación para que el contenido salga centrado. Esto no lo hacemos con el layout de la izquierda porque queremos que tenga el tamaño ajustado a su contenido.

Del layout de la izquierda, justamente, nos ocupamos ahora: le agregamos el nombre del archivo que abrimos, una tabla con los datos, y una serie de \textit{radiobuttons} para permitir elegir la función de ajuste. Poner el nombre del archivo es sencillo (líneas 78 a 81); ya usamos \texttt{QLabel} anteriormente, el único detalle es que le seteamos un flag para que el texto quede centrado. Poner los radiobuttons es apenas más complicado (líneas 92 a 97): agregamos los tres que necesitamos directamente en un layout vertical, sin necesitar hacer más nada porque como tenemos un sólo grupo de radiobuttons podemos usar el default (recordemos que los radiobuttons trabajan en grupo porque al habilitar uno se deshabilita el resto); notemos que por ahora no conectamos estos botones a ninguna acción.

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-06-1.png}
\end{center}

Para la tabla con datos necesitamos un poco más de explicación. Vemos en el código que hay un \texttt{QTableView} y un \texttt{TableModel}. Esta estructura con distintas partes existe porque las tablas ofrecen toda una funcionalidad que en realidad no estamos usando en nuestro ejemplo (piensen que ``una planilla de cálculos'' también termina siendo una tabla de datos compleja con una gran cantidad de detalles e interacciones).

Así y todo no es tan complicado, pero el concepto fundamental que tenemos que entender es que nos tenemos que encargar de esas dos partes: la ``vista'' de los datos (que se ocupa de cómo mostrar la información y cómo interactuar con la misma) y el ``modelo'' de los datos, que se encarga de recuperar el valor de cada celda (que puede ser de una tabla fija como tenemos nosotros o de una base de datos), guardar también cambios en esos valores (si la tabla fuese editable), y en general proveer toda la información con respecto a los datos (como cuantas filas o columnas hay).

En el panel principal entonces nos encargamos directamente de la vista de la tabla (líneas 83 a 90). Creamos una \texttt{QTableView}, le ponemos un modelo (una clase propia que veremos a continuación), y antes de agregarla al layout le configuramos su \textit{look \& feel}: indicamos que no se vea la cabecera vertical (lo que sería el número de cada fila), y le indicamos que a la cabecera horizontal se le puede cambiar los tamaños (permitiendo ajustar el ancho de cada columna), y que la última columna se ``estire'' hasta ocupar el ancho de toda la tabla. Noten como en ese código no hay nada con respecto a los datos en sí, sólo se los pasamos al modelo al instanciar \texttt{TableModel}.

\pyfile[firstline=25, lastline=58]{Chapters/guis/code/06.leftpanel.py}

Nuestro modelo es una clase que hereda de \texttt{QAbstractTableModel} y su funcionamiento se basa en proveer distintos métodos estándares que la vista va a consultar para obtener distintas informaciones. En nuestra clase definimos algunos métodos, los necesarios para proveer información sobre los datos de nuestra tabla simple y estática. Y el \texttt{\_\_init\_\_} para inicializar la clase, donde guardamos la tabla en la instancia luego de inicializar la clase ancestra.

Cada uno de estos métodos están bien definidos en la documentación: para qué sirve cada uno, qué información reciben al ser ejecutados y qué tienen que devolver. No vamos a explicar todo lo que podría proveer \texttt{QAbstractTableModel} porque sería demasiado largo, pero entremos en detalle al menos con los que usamos en nuestro modelo para ayudarles a entender el código de nuestro ejemplo y facilitarles la entrada a la documentación más compleja cuando la tengan que usar.

\begin{itemize}
    \item \texttt{headerData}: este método devuelve información relacionada con las cabeceras; en nuestro caso sólo nos interesa proveer los ``títulos'' de cada columna, por eso sólo contestamos información para el caso de la cabecera horizontal (\texttt{orientation == Qt.Orientation.Horizontal}) y con respecto a cómo se muestran (\texttt{role == Qt.ItemDataRole.DisplayRole}), devolviendo \texttt{X} para la primer columna e \texttt{Y} para la segunda.
    \item \texttt{data}: este método es el que usa la vista para obtener los datos de cada celda; implementamos dos roles, \texttt{DisplayRole} donde devolvemos cada dato (formateado) según fila y columna, y \texttt{TextAlignmentRole} para la alineación, mucho más sencillo porque todas las celdas están alineadas igual (al centro en lo vertical y a la derecha en lo horizontal).
    \item \texttt{rowCount} y  \texttt{columnCount}: devuelven la cantidad de filas y de columnas, dato que se obtiene fácilmente de la tabla fuente más allá de por qué indice hayan sido consultados (ya que la tabla es rectangular).
\end{itemize}

El próximo paso es usar una función para ajustar los datos a una función polinómica, generar el gráfico y mostrarlo. Para ello, ya en el código \texttt{07.fitgraph.py}, tenemos una función \texttt{fit} que recibe los datos y el grado de la función a utilizar.

\pyfile[firstline=37, lastline=70]{Chapters/guis/code/07.fitgraph.py}

A las funciones polinómicas las tenemos definidas en el diccionario \texttt{functions\_to\_fit} de acuerdo a lo que vamos a necesitar para \texttt{curve\_fit} de la biblioteca SciPy. La función \texttt{fit} toma entonces la función polinómica según el grado recibido, separa los datos en dos columnas y obtiene (usando SciPy) los parámetros de la función polinómica y las covarianzas, y con esta información genera dos productos: los textos indicando el valor y error de cada parámetro, y una figura de \texttt{matplotlib} con todo dibujado (los puntos originales y la función polinómica calculada).

Para utilizar esta función conectamos a los radiobuttons que creamos anteriormente a un método nuestro.

\pyfile[firstline=168, lastline=171]{Chapters/guis/code/07.fitgraph.py}

Vemos en la línea 170 que conectamos la señal \texttt{clicked} de cada radiobutton a una función creada ahí mismo con \texttt{partial}, que al ejecutarse llamará a \texttt{self.calculate} pasando automáticamente \texttt{degree} como parámetro

\pyfile[firstline=176, lastline=208]{Chapters/guis/code/07.fitgraph.py}

Este método \texttt{calculate} es el que ejecutará la función \texttt{fit}. En caso de error llamará a otro método que mostrará el error utilizando nuestro método de la ventana principal, más todo el \textit{traceback} por la terminal.

En caso de que haya salido todo bien pasará ese resultado a otro método, \texttt{show\_result}, cuya responsabilidad es crear un panel de resultados (que veremos a continuación) y agregarlo al layout de la derecha, o en caso de tener otro panel de antes, cerrar el viejo y reemplazarlo.

Veamos entonces \texttt{ResultPanel} que es el que se encarga de mostrar la info resultado. Recibe la instancia del panel principal, los parámetros de la función, y la figura de matplotlib:

\pyfile[firstline=109, lastline=131]{Chapters/guis/code/07.fitgraph.py}

Como ya vimos en otros casos, la instancia primero inicializa el widget del que hereda, guarda algún parámetro recibido y crea un layout para agregar contenido. En este caso tenemos dos elementos: un \textit{text edit} al que le ponemos varias líneas con los parámetros recibidos, y el gráfico.

Para el gráfico usaremos funcionalidad que \texttt{matplotlib} misma provee para integrarse con Qt: un \textit{canvas} para agregar la figura y una barra de herramientas (conectada a esa canvas) para que se pueda interactuar con el gráfico. A la barra de tareas la podemos ubicar en cualquier lado, pero a nivel usabilidad lo mejor es que sea una barra más de la ventana principal, entonces en la línea 126 la agregamos allí. Pero al hacer esto tenemos que tener la precaución de que cuando se cambie el gráfico tenemos que sacar la barra del gráfico anterior, y eso lo hacemos en el método \texttt{close} de nuestra clase (línea 130).

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-07-1.png}
\end{center}

La próxima iteración de código, en \texttt{08.notblocking.py}, está pensada para ejemplificar cómo podemos soportar aquellas situaciones donde algo tarda demasiado. Como Qt es un sistema asincrónico en realidad no podemos bloquearlo con ninguna operación que tarde más que algunas decenas de milisegundos, porque mientras el sistema está bloqueado no va a poder procesar ningún evento, y esto a nivel de experiencia de usabilidad se traduce en que la ventana se ``congela'', no responde al teclado o el mouse, e incluso puede aparecer a medio dibujar en la pantalla (recordemos que Qt no sólo procesa eventos nuestros sino también del sistema operativo, y si no puede procesar nada porque está bloqueado no se va a comportar correctamente).

En nuestro ejemplo el \textit{cálculo científico} que hacemos es bastante rápido, ya que es un simple ajuste de datos, pero simulemos un potencial cálculo más costoso agregando una demora artificial de cinco segundos en la función \texttt{fit}:

\pyfile[firstline=72, lastline=74]{Chapters/guis/code/08.notblocking.py}

Para soportar casos de funciones que tardan mucho en ejecutarse y no bloquear la interfaz gráfica debemos ejecutar esa función en otro hilo o \textit{thread}, para lo cual creamos una clase auxiliar, \texttt{ThreadedTask}:

\pyfile[firstline=115, lastline=141]{Chapters/guis/code/08.notblocking.py}

Esta clase es bien simple, pero el truco es que hereda de \texttt{threading.Thread}, que es una de las maneras de armar hilos en Python (más sobre hilos en el capítulo de procesamiento paralelo \ref{sec:multithreading}). En el método de inicialización recibe la función a ejecutar y cualquier cantidad de argumentos posicionales y nombrados, y guarda todo en la instancia. Además inicializa un objeto con dos señales (definido en las líneas 115 a 118), para los casos de terminar satisfactoriamente o en error, y por supuesto llama al inicializador de la clase ancestra (requisito fundamental para que el hilo funcione).

Luego en el método \texttt{run} (que es el punto de entrada cuando se ejecuta el hilo) simplemente se ejecuta la función y guarda el resultado, con la precaución de soportar cualquier error. Si todo estuvo bien se emite la señal \texttt{success} pasando el resultado, y si algo salió mal se emite la señal \texttt{error} pasando la excepción ocurrida, y luego el hilo termina.

Volvamos al código de \texttt{MainPanel} para ver cómo usamos esa clase auxiliar. Aquí tenemos que reescribir el método \texttt{calculate} que es donde ejecutábamos la función:

\pyfile[firstline=211, lastline=219]{Chapters/guis/code/08.notblocking.py}

Ahora, además de poner el estado en ``Calculando'', inicializamos \texttt{ThreadedTask} pasando la función \texttt{fit}, los datos y el grado de la función de ajuste, y conectamos sus señales: la de éxito para mostrar el resultado, y la de error para mostrar la excepción ocurrida (¡notar que esas dos funciones no cambiaron! ya recibían el resultado o la excepción desde antes). Finalmente llamamos al método \texttt{start} de la clase auxiliar para que el hilo arranque.

Todo este trabajo que hicimos no tiene un impacto directo en la interfaz del usuario (no hay un botón nuevo, o se muestra distinta alguna información), pero es fundamental a la hora de tener una aplicación que no se congele y que no de la sensación al usuario de que ``algo salió mal''.

Por otro lado, aunque ahora la aplicación se mantiene responsiva, en realidad no nos está dando ninguna indicación que nos ayude a darnos cuenta que está haciendo un cálculo que lleva tiempo y que tenemos que esperar. Implementamos esto en la próxima iteración del código, \texttt{09.complete.py}, que es la versión final de nuestra aplicación.

Históricamente la forma de las interfaces gráficas de mostrar que ``se está realizando alguna tarea y hay que esperar'' es mediante un \texttt{throbber} (un término sin traducción al castellano para esta acepción), que es una imagen animada, en general circular, que va ``girando'' mientras tenemos que esperar.

Agreguemos entonces un throbber a nuestro programa. El mismo tiene que verse cuando arranca el cálculo, y sacarse cuando tenemos el gráfico resultado. Si elegimos otro grado para la función de ajuste tenemos que sacar el gráfico y poner el throbber para esperar el nuevo cálculo. En la práctica, lo que sucede es que en el layout derecho, luego de iniciar el primer cálculo, vamos a ir alternando entre mostrar un throbber y el panel de resultados.

En el método \texttt{MainPanel.calculate} tenemos entonces que poner el throbber antes de crear e iniciar el hilo con el cálculo:

\pyfile[firstline=216, lastline=227]{Chapters/guis/code/09.complete.py}

Crear el throbber es sencillo (líneas 216 a 219) porque nos basamos en tener un GIF animado en un archivo \texttt{throbber.gif} que cargamos con \texttt{QMovie} (un widget para mostrar animaciones simples sin sonido), que para insertarlo en la interfaz ponemos dentro de un \texttt{QLabel} (como haríamos con un texto o una imagen).

Inmediatamente después en las líneas 221 a 227 agregamos el throbber al layout derecho, directamente si no había un panel de antes, o reemplazando un panel anterior (y cerrándolo).

\begin{center}
    \includegraphics[scale=0.50]{Chapters/guis/imgs/sshot-09-1.png}
\end{center}

Luego de agregarlo, tenemos que considerar cuando sacarlo. Esto sucede en los métodos \texttt{on\_error} y \texttt{show\_result}, que se ejecutan cuando terminó el cálculo por error o satisfactoriamente, cerrando y eliminando el throbber en el primer caso...

\pyfile[firstline=243, lastline=244]{Chapters/guis/code/09.complete.py}

..., o cerrándolo y reemplazándolo por el panel de resultados en el segundo.

\pyfile[firstline=250, lastline=252]{Chapters/guis/code/09.complete.py}

Llegamos entonces al final de nuestro recorrido, con una interfaz completa y funcional.

Vuestras necesidades de interfaz van a ser distintas, obviamente, pero siempre serán en mayor o menor medida alguna variación de lo que ya vimos en este capítulo, usando también otros widgets más o menos complejos.

Lo importante es que ya saben cómo arrancar.
